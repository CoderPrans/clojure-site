= Deps and CLI
Alex Miller
2017-11-30
:type: reference
:toc: macro
:icons: font
:prevpagehref: lisps
:prevpagetitle: Differences with Lisps

ifdef::env-github,env-browser[:outfilesuffix: .adoc]

toc::[]

= Rationale

Clojure "endeavors to be a general-purpose language suitable in those areas where Java is suitable" (from <<xref/../../about/rationale#,Rationale>>). To effectively target the JVM platform, Clojure needs to provide ready access to Java libraries, ideally in a way suited for dynamic development. In practice, this means meeting the JVM platform in two places:

* the classpath used when invoking JVM processes (and/or URLClassLoaders)
* transitive dependency download and resolution from providers like Maven

Clojure build tools have traditionally taken the approach of wrapping the Maven ecosystem to gain access to Java libraries. However, they have also forced this approach on Clojure code as well, requiring a focus on artifacts that must be built and deployed (which Clojure does not require). This approach has created friction for Clojure developers, making it hard to e.g. work with libs not yet publishing artifacts, work on speculative changes w/o artifacts or across multiple libs, or give control to a 3rd party to manage shared dependencies.

To this end Clojure provides:

* https://github.com/clojure/tools.deps.alpha[tools.deps.alpha] - a library providing an API for resolving dependency graphs and building classpaths that can utilize both Maven and other providers of code or artifacts
* Command line tools (`clojure` and `clj`) that enable users to make use of this capability at the terminal to declare dependencies, assemble classpaths, and launch Clojure programs with data
* System-specific installers for downloading the tools, improving the "Getting Started" experience

= Overview

You use the Clojure tools (`clj` or `clojure`) to run Clojure programs on the JVM, e.g. to start a REPL or invoke a specific function with data. The Clojure tools will configure the JVM process by defining a classpath (with desired libraries), an execution environment (JVM options), the main class, and args.

Using a deps.edn file (or files), you tell Clojure where your source code resides and what libraries you need. Clojure will then calculate the full set of required libraries and a classpath, caching expensive parts of this process for better performance.

The internal steps of the Clojure tools, as well as the Clojure functions you intend to run, are parameterized by data structures, often maps. Shell command lines are not optimized for passing nested data, so instead you will put the data structures in your deps.edn file and refer to them on the command line via _aliases_ - keywords that name data structures.

`clj` and `clojure` differ in that `clj` has extra support for use as a REPL in a terminal, and should be preferred unless you don't want that support, then use `clojure`. The invocation structure is the same for both:

[source]
----
clj     [clj-opt*] [execution-specifier]
clojure [clj-opt*] [execution-specifier]
----

== Start a REPL

To run a REPL, invoke `clj` without any execution-specifier:

[source]
----
$ clj
Clojure 1.10.1
user=>
----

== Executing a function that takes a map

_Available in clj 1.10.1.619 or higher, currently only in prerelease_

You can use the following execution specifier to invoke a function that takes a map:

[source]
----
clojure [clj-opt*] -X[:aliases] [a/fn] [kpath v]*
----

The aliases are looked up in the deps.edn and combined into a composite arg map. The arg map is used both to influence how the classpath is built (more on that below) and to persist invocation details.

You can specify the function to invoke either on the command line, or with the `:exec-fn` key in the arg map (command line takes precedence). The function is resolved in a namespace based on the following rules:

* If function is unqualified, use the namespace in the `:ns-default` key in the arg map (if none, this is an error)
* If function is qualified, and the qualifier is an alias in the arg map under `:ns-aliases`, use that namespace
* Else use the fully qualified function symbol

The function is invoked with a map. The base map can be supplied in the arg map under the `:exec-args` key and can also be overridden or supplied at the command line.

For example, to invoke a function in your project:

[source,clojure]
----
clj -X my.project.util/start-server :port 5555
----

This will invoke the function `(my.project.util/start-server {:port 5555})`. 

If you have many utility functions in that namespace, you might want to set it up as a default in your `deps.edn`:

[source,clojure]
----
;; deps.edn
{:aliases
 {:my-project
  {:ns-default my.project.util}}}
----

This simplifies the invocation and also lets you call any other utility function in that namespace:

[source]
----
clj -X:my-project start-server :port 5555
clj -X:my-project new-user :name '"Kermit"' :color :green
----

If you also have a set of database utility functions, supply a namespace alias for it:
[source,clojure]
----
;; deps.edn
{:aliases
 {:my-project
  {:ns-default my.project.util
   :ns-aliases {db my.project.dbutil}}}}
   
clj -X:my-project db/install-schema :schema '"db/my.schema"'
----

As you saw above, you can supply key-path/value pairs on the command line. The key-path is either a single key or a vector of keys to refer to a nested key (as with `assoc-in`). Each key-path will be used to `assoc-in` to the original `:args` map, overriding the value there.

[source]
----
# Top key override
clj -X:my-fn :val 789

# Nested key override
clj -X:my-fn '[:my :data]' 789
----

[NOTE]
====
See the later section on "Quoting keys and values" for more details on how to properly quote edn values on the command line.
====

== Running a main or script

You can also use a `-M` specifier to invoke clojure.main, which supports calling a namespace with a `-main` function or running a Clojure script:

[source]
----
clojure [clj-opt*] -M[:aliases] [main-opts]
----

The -M aliases are pulled from `deps.edn` and combined to form an arg map. The arg map can modify the classpath or supply main options.

See the <<repl_and_main#,clojure.main>> documentation for more details on the main options.

= Operation

When you execute the Clojure tool, there are a series of steps performed to prepare and execute your command. This section is an overview of those steps, see later sections for how to modify those steps in a variety of ways.

== Locate deps.edn sources

Configuration is stored in one or more "deps.edn" maps. These are edn maps with the following top-level keys:

* `:deps` - map of lib (symbol) to coordinate
* `:paths` - vector of paths
* `:aliases` - map of alias name to alias data
* provider-specific keys for configuring dependency sources

The Clojure tools look for 4 potential deps.edn sources:

* Root - found in the installation of clj (or as a resource in tools.deps)
* User - cross-project configuration (typically tools), usually found at `~/.clojure/deps.edn`
* Project - the `deps.edn` in the current directory
* Config data - a `deps.edn` map passed on the command line

== Check cache

The next several steps of this execution can be skipped if we have already computed the classpath and cached it. Classpath and the runtime basis files are cached in the current directory under `.cpcache/`. The key is based on the contents of the deps.edn files and some of the command arguments passed and several files will be cached, most importantly the classpath and runtime basis.

If the key is found, and the cached files are newer than all deps.edn sources, they will be used and execution begins immediately.

== Replace project environment ("tool")

When you execute a tool in the context of your project, the tool can use its own paths and/or deps in place of the project's paths and/or deps.

== Merge sources

All deps.edn sources are merged into a single master edn file in the order listed above - root, user, project (possibly with tool replacements), config. This merged deps will be included in the runtime basis and used after this point.

deps.edn sources is essentially `merge-with merge`, except for the `:paths` key, where only the last `:paths` found is used (they replace, not combine).

== Resolve dependencies

Starting from the master edn's merged :deps, the full transitive expansion of the dependency tree is computed. Dependency sources (procurers) are used to obtain metadata and other dependency information. At the completion of this step, all libraries to use in the execution have been found and downloaded to local files if needed.

== Make classpath

JVM execution relies on computing the classpath for the execution. The classpath will consist of the `:paths` in the merged `deps.edn` and the locations of all resolved dependencies.

== Prepare JVM environment

JVM arguments may either be passed on the command line (with `-J`) or by using data stored in an alias under `:jvm-opts` and passed with `-O` or `-A`

== Execute command

Finally the command is executed - see the Overview above for the execution options. The already computed (or loaded from cache) classpath, JVM environment, and main arguments if relevant are used in the execution. 

= deps.edn

The configuration file format (in `deps.edn` files) is an edn map with top-level keys `:deps`, `:paths`, and `:aliases`, plus provider-specific keys for configuring dependency sources.

== Paths

Paths are declared in a top level key `:paths` and are a vector of string paths or alias names. Relative paths are resolved in relation to the directory containing the deps.edn (the project root). These source paths will be added to the classpath.

Example:

[source,clojure]
----
{:paths ["src"]}
----

If used, alias names should refer to a path vector in the alias data:

[source,clojure]
----
{:paths [:clj-paths :resource-paths]
 :aliases
 {:clj-paths ["src/clj" "src/cljc"]
  :resource-paths ["resources"]}}
----

== Dependencies

Dependencies are declared in deps.edn with a top level key `:deps` - a map from library to coordinate. Libraries are symbols of the form `<groupID>/<artifactId>`. To indicate a Maven classifier, use `<groupId>/<artifactId>$<classifier>`.

Coordinates can take several forms depending on the coordinate type:

* Maven coordinate: `{:mvn/version "1.2.3"}`
** Other optional keys: `:exclusions`
** Note: `:classifier` is not supported - add to lib name as specified above
* Local project coordinate: `{:local/root "/path/to/project"}`
** Optional key `:deps/manifest`
*** Specifies the project manifest type
*** Default is to auto-detect the project type (currently either `:deps` or `:pom`)
* Local jar coordinate: `{:local/root "/path/to/file.jar"}`
** If the jar includes a pom.xml file, it will be used to find transitive deps
* Git coordinate: `{:git/url "https://github.com/user/project.git", :sha "sha", :tag "tag"}`
** Required key `:git/url` can be one of the following:
*** https - secure anonymous access to public repos
*** ssh or user@host form urls (including GitHub) - ssh-based access (see Git configuration section)
** Required key `:sha` should indicate the full commit sha
** Optional key `:tag` is used only to indicate the semantics of the sha
** Optional key `:deps/root`
*** Specifies the relative path within the root to search for the manifest file
** Optional key `:deps/manifest` - same as in `:local` deps

[source,clojure]
----
{:deps
 {org.clojure/tools.reader {:mvn/version "1.1.1"}
  github-sally/awesome {:git/url "https://github.com/sally/awesome.git", :sha "123abcd549214b5cba04002b6875bdf59f9d88b6"}
  ;; ... add more here
 }}
----

== Aliases

Aliases give a name to a data structure that can be used either by the Clojure tool itself or other consumers of deps.edn. They are defined in the `:aliases` section of the config file. These Clojure tool subprocesses use data which can be read from aliases:

= Basis and classpath

_Available in clj 1.10.1.619 or higher, currently only in prerelease_

The core of the tools.deps library is a process to take a merged deps.edn file, arg maps for the resolve-deps and make-classpath steps, and produce the "runtime basis", or "basis" for short. The basis is a superset of the deps.edn file also containing those args, the lib map, and the classpath map.

The JVM classpath consists of a series of roots, either directory paths or the path to a jar file. Classes (and Clojure files) map via package or namespace to a path relative to a classpath root. For example, the `java.lang.String` class can be found at path `java/lang/String.class` and the `clojure.set` Clojure namespace may be found at paths `clojure/set.class` (for AOT), `clojure/set.clj`, or `clojure/set.cljc`. When the JVM needs to load one of these files it searches each root for the relative path and loads it when found.

We divide the process of building a classpath into two primary operations: `resolve-deps` and `make-classpath`.

== resolve-deps

**`(resolve-deps deps args-map)`**

`resolve-deps` takes an initial map of required dependencies and a map of args that modify the resolution process. It builds a full graph of transitive dependencies, resolves any version differences, and flattens that graph to a full list of libraries to be included on the classpath.

The deps from the merged deps.edn is a map of library to coordinate. The library is (in Maven terms) the groupId and artifactId, which are sufficient to locate the desired project. The coordinate is used to describe a particular version that is being requested from a particular provider (like Maven or git).

For example, this deps map specifies a (Maven-based) dependency:

[source,clojure]
----
{org.clojure/core.cache {:mvn/version "0.6.5"}}
----

`resolve-deps` expands these dependencies to include all transitive dependencies, cut cycles, resolve version differences, download required artifacts from the provider, and produce a *lib map* of the flattened set of all needed dependencies and where to find their artifacts:

[source,clojure]
----
{org.clojure/core.cache        {:mvn/version "0.6.5",
                                :deps/manifest :mvn,
                                :paths [".../core.cache-0.6.5.jar"]}
 org.clojure/data.priority-map {:mvn/version "0.0.7",
                                :deps/manifest :mvn,
                                :dependents [org.clojure/core.cache],
                                :paths [".../data.priority-map-0.0.7.jar"]} 
 ... }
----

The lib map lists all libraries, their selected coordinates, the `:paths` on disk, and a list of dependents that caused it to be included. Here you can see that `data.priority-map` was included as a dependency of core.cache.

The second `args-map` is a map of optional modifications to the standard expansion to account for common use cases: adding extra dependencies, overriding deps, and default deps. These can be used separately or together, or not at all:

[source,clojure]
----
{:extra-deps { ... }
 :override-deps { ... }
 :default-deps { ... }}
----

`:extra-deps` is the most common modification - it allows you to optionally add extra dependencies to the base dependency set. The value is a map of library to coordinate:

[source,clojure]
----
{:extra-deps {criterium/criterium {:mvn/version "0.4.4"}}}
----

`:override-deps` overrides the coordinate version chosen by the version resolution to force a particular version instead. This also takes a map of library to coordinate:

[source,clojure]
----
{:override-deps {org.clojure/clojure {:mvn/version "1.9.0"}}}
----

`:default-deps` provides a set of default coordinate versions to use if no coordinate is specified. The default deps can be used across a set of shared projects to act as a dependency management system:

[source,clojure]
----
{:default-deps {org.clojure/core.cache {:mvn/version "0.6.4"}}}
----

== make-classpath

**`(make-classpath lib-map paths args-map)`**

The `make-classpath` step takes the lib map (the result of `resolve-deps`), the internal source paths of the project `["src"]`, an args-map of optional modifications, and produces a classpath string for use in the JVM.

The args-map includes support for modifications to be applied while making the classpath: adding extra paths, and overriding the location of libraries specified in the lib map. These modifications can be used separately or together or not at all in a map like this:

[source,clojure]
----
{:extra-paths [ ... ]
 :classpath-overrides { ... }}
----

`:extra-paths` is used to include source paths in addition to your standard source paths, for example to include directories of test source:

[source,clojure]
----
{:extra-paths ["test" "resources"]}
----

`:classpath-overrides` specify a location to pull a dependency that overrides the path found during dependency resolution, for example to replace a dependency with a local debug version. Many of these use cases are ones where you would be tempted to prepend the classpath to "override" something else.

[source,clojure]
----
{:classpath-overrides 
 {org.clojure/clojure "/my/clojure/target"}}
----

= Clojure tools usage

== deps.edn sources

The Clojure tools will use the following deps.edn map sources, in this order:

* Root - found in the installation of clj (or as a resource in tools.deps)
* User - cross-project configuration (typically tools)
** Locations used in this order:
*** If `$CLJ_CONFIG` is set, then use `$CLJ_CONFIG` (explicit override)
*** If `$XDG_CONFIG_HOME` is set, then use `$XDG_CONFIG_HOME/clojure` (Freedesktop conventions)
*** Else use `$HOME/.clojure` (most common)
* Project - the `deps.edn` in the current directory
* Config data - a `deps.edn` map passed on the command line

The deps.edn sources can be modified or inspected by the following options:

* `-Sverbose` - print all source locations
* `-Sdeps` - pass the config data on the command line
* `-Srepro` - omit the user deps source (other sources will be used if found)

== Classpath caching

The cached classpath file is used for execution when:

* It exists and
* It is newer than all `deps.edn` sources

Classpath and basis files are cached in a directory computed as follows:

* If there is a project deps.edn
** Use `./.cpcache`
* Else (no project deps.edn)
** If `$CLJ_CACHE` is set, then use `$CLJ_CACHE` (explicit override)
** If `$XDG_CACHE_HOME` is set, then use `$XDG_CACHE_HOME/clojure` (Freedesktop conventions)
** Else use `config_dir/.cpcache` (see deps.edn sources for config_dir logic, usually `~/.clojure`)

A hash is computed based on the config file paths, the resolve-aliases, and the classpath aliases.

Files cached (if needed):

* `<hash>.libs` - a `::lib-map` in the https://github.com/clojure/tools.deps.alpha/blob/master/src/main/clojure/clojure/tools/deps/alpha/specs.clj[specs], the output of running `resolve-deps`
* `<hash>.cp` - a classpath string, the output of `make-classpath`
* `<hash>.jvm` - jvm options for main execution
* `<hash>.main` - main options for main execution
* `<hash>.basis` - the runtime basis, for injection

Caching can be modified by the following options:

* `-Sforce` - ignore cache and force recomputation
* `-Scp CP` - don't use cache or compute, use the provided classpath instead

== Replace project environment (tool)

The `tool` process is used when executing a tool that should not use the project classpath environment. This process takes the project deps.edn and the following modifier args and replaces them (if provided) before the project deps is merged:

* `:replace-deps` - a deps map from lib to coordinate of deps to REPLACE the project `:deps`
* `:replace-paths` a collection of string paths to REPLACE project `:paths`

This tool map should be provided as an alias in one of the deps sources and provided to the Clojure tools using -A, -M, or -X. Multiple aliases can be provided by concatentating the alias names.

== Merging deps.edn

The `deps.edn` files found from the source locations (with Clojure tool modifications by any options) are merged to form one master deps map. The merge is done in the order above root/user/project/config, last one wins. The operation is essentially `merge-with merge`, except for the `:paths` key, where only the last one found is used (they are not combined).

== Resolve deps modifiers

The resolve-deps modifiers are provided in a map that was described in a prior section:

* `:extra-deps` - a deps map from lib to coordinate of deps to add to the deps
* `:override-deps` - a deps map from lib to coordinate of override versions to use
* `:default-deps` - a deps map from lib to coordinate of versions to use if none is found
* If multiple alias maps with these keys are activated, all of them are merge-with merged

The resolve-deps args should be provided as an alias in one of deps sources and provided to the Clojure tools using either `-R:an-alias` or `-A:an-alias`. Multiple aliases can be provided by concatentating the alias names.

== Make classpath modifiers

The make-classpath modifiers are provided in a map that was described in a prior section:

* `:extra-paths` - a collection of string paths to add to `:paths`
* `:classpath-overrides` - a map of lib to string path to replace the location of the lib
* If multiple maps with these keys are activated, `:extra-paths` concatenate and `:classpath-overrides` merge-with merge

The resolve-deps args should be provided as an alias in one of deps sources and provided to the Clojure tools using either `-C:an-alias` or `-A:an-alias`. Multiple aliases can be provided by concatentating the alias names.

== Prepare JVM environment

The JVM has many options and some programs also take configuration via Java system properties. JVM options can be passed on the command line for any execution specfier by prefixing with `-J`. If multiple options are specified, each must be prefixed.

Additionally, main execution can take a map with key `:jvm-opts`:

* `:jvm-opts` - a collection of string JVM options
* If multiple maps with these keys are activated, `:jvm-opts` concatenate
* If -J JVM options are also specified on the command line, they are concatenated after the alias options

This map is stored in alias data and provided to the Clojure tools using either `-O:an-alias` or `-A:an-alias`.  Multiple aliases can be provided by concatentating the alias names.

== Execution

Execution options were mostly covered in the earlier Overview section.

=== Main execution

One additional option for main execution is a map with key `:main-opts`:

* `:main-opts` - a collection of clojure.main options
* If multiple maps with these keys are activated, only the last one will be used
* If command line clojure.main arguments are supplied on the command line, they are concatenated after the last main alias map

This map is stored in alias data and provided to the Clojure tools using either `-M:an-alias` or `-A:an-alias`. Multiple aliases can be provided by concatentating the alias names.

=== Basis injection

_Available in clj 1.10.1.619 or higher, currently only in prerelease_

The Clojure tools inject the computed runtime basis into the executed process using the Java system property `clojure.basis` which points to the cached basis file. Programs can read the basis file as edn and use it themselves if needed.

Example code:

[source,clojure]
----
(require '[clojure.java.io :as jio] '[clojure.edn :as edn])
(def basis (-> (System/getProperty "clojure.basis") jio/file slurp edn/read-string))
----

The basis is a superset of the master deps edn and will also contain the additional keys: `:resolve-args`, `:classpath-args`, `:libs`, and `:classpath`.

== Other programs

There are some options that can be provided to `clj` that short circuit normal execution and run an alternate program instead:

* `-Sdescribe` - print environment and command parsing info as data
* `-Stree` - print dependency tree
* `-Spath` - compute classpath and echo to stdout only
* `-Spom` - generate (or update an existing) pom.xml with deps and paths
* `-Sresolve-tags` - resolve git coordinate tags to shas and update deps.edn

=== Local Maven install

_Available in clj 1.10.1.619 or higher, currently only in prerelease_

The `clojure.tools.deps.alpha.tools.install/install` program is provided with the Clojure tools for convenience and can be executed with `-X` to install a jar into your local Maven cache.

The install argmap takes the following options:

[source,plain-text]
----
:jar (required) - path to jar file
:pom (optional) - path to pom file
:lib (optional) - qualified symbol like my.org/lib
:version (optional) - string
:classifier (optional) - string
:local-repo (optional) - path to local repo (default = ~/.m2/repository)
----

Add the tool configuration to your `deps.edn` under an alias:

[source,clojure]
----
{:aliases
 {:install
  {:fn clojure.tools.deps.alpha.tools.install/install
   ;; :args map could be provided but can pass on command line instead
   }}}
----

To execute use the built-in `:deps` alias to include tools.deps.alpha on the classpath, execute the install tool with -X and pass the args on the command line:

[source,shell]
----
clj -A:deps -X:install :jar '"/path/to.jar"'
----

As mentioned above, edn strings must be in double quotes, and then single-quoted for the shell.

The install tool will find the pom inside the jar file (if it exists) and use that to determine the groupId, artifactId, and version coordinates to use when the jar is installed. Alternately, you can provide a pom file or specific coordinates via the other attributes.

= Procurers

Coordinates are interpreted by procurers, which know how to determine dependencies for a library and download artifacts. tools.deps.alpha is designed to support an extensible set of procurers that can expand over time. Currently the available procurers are: `mvn`,  `local`, and `git`.

The procurer to use is determined by examining the attributes of the coordinate and using the first attribute qualifier that's found (ignoring the reserved qualifier "deps"). For example, a Maven coordinate contains a `:mvn/version` attribute and a local coordinate contains a `:local/root` attribute.

Procurers may also have configuration attributes stored at the root of the configuration map under the same qualifier. 

== Maven

The `mvn` procurer will look for `:mvn/repos`. The installation deps.edn configures the default Maven repos:

[source,clojure]
----
{:mvn/repos
 {"central" {:url "https://repo1.maven.org/maven2/"}
  "clojars" {:url "https://clojars.org/repo"}}}
----

=== Modifying the default repositories

The `:mvn/repos` map is `merge-with` `merge` across the deps.edn sources, so you can modify the default repositories by specifying a new definition or remove it by specifying `nil`.

tools.deps guarantees that the `"central"` and `"clojars"` repositories will be checked first for Maven libraries.

=== Maven authenticated repos

For Maven deps in authenticated repositories, existing Maven infrastructure is used to convey credentials.

In your `~/.m2/settings.xml`:

[source,xml]
----
<settings>
  ...
  <servers>
    <server>
      <id>my-auth-repo</id>
      <username>zango</username>
      <password>123</password>
    </server>
    ...
  </servers>
  ...
</settings>
----

Then in your `deps.edn` include a repo with a name matching the server id (here `my-auth-repo`):

[source,clojure]
----
{:deps
 {authenticated/dep {:mvn/version "1.2.3"}}
 :mvn/repos
 {"my-auth-repo" {:url "https://my.auth.com/repo"}}}
----

Then just refer to your dependencies as usual in the `:deps`.

=== Maven S3 repos

The tools also provide support for connecting to public and private S3 Maven repositories.

Add a `:mvn/repos` that includes the s3 repository root:

[source,clojure]
----
{:deps
 {my/library {:mvn/version "0.1.2"}}
 :mvn/repos
 {"my-private-repo" {:url "s3://my-bucket/maven/releases"}}}
----

S3 buckets are specific to the AWS region they were created in. The s3 transporter will attempt to determine the bucket's location. If that doesn't work, you can specify the bucket region in the url explicitly: `"s3://my-bucket/maven/releases?region=us-west-2"`.

For authenticated repos, AWS credentials can be set in the `~/.m2/settings.xml` on a per-server basis or will be loaded ambiently from the AWS credential chain (env vars, etc). The repository name in `deps.edn` must match the server id in `settings.xml`:

[source,xml]
----
<settings>
  ...
  <servers>
    <server>
      <id>my-private-repo</id>
      <username>AWS_ACCESS_KEY_HERE</username>
      <password>AWS_SECRET_ACCESS_KEY_HERE</password>
    </server>
    ...
  </servers>
  ...
</settings>
----

AWS S3 credentials can be set in the environment using one of these mechanisms:

1. Set the environment variables `AWS_ACCESS_KEY_ID` and `AWS_SECRET_ACCESS_KEY`.
2. Create a default profile in the AWS credentials file `~/.aws/credentials` (older `~/.aws/config` also supported).
3. Create a named profile in the AWS credentials file and set the environment variable `AWS_PROFILE` with its name.
4. Amazon ECS container and instance profile credentials should also work, but have not been tested.

For more information, most of the advice in https://docs.aws.amazon.com/sdk-for-java/v1/developer-guide/credentials.html[this AWS document] describes how credentials are located. Note however that the Java system properties options will NOT work with the command line tools (but would work if using the tools.deps.alpha library directly).

=== Maven proxies

In environments where the internet is accessed via a proxy, existing Maven configuration in `~/.m2/settings.xml` is used to set up the proxy connection:

[source,xml]
----
<settings>
  ...
  <proxies>
    <proxy>
      <id>my-proxy</id>
      <host>proxy.my.org</host>
      <port>3128</port>
      <nonProxyHosts>localhost|*.my.org</nonProxyHosts>
    </proxy>
  </proxies>
  ...
</settings>
----

Refer to the Maven https://maven.apache.org/guides/mini/guide-proxies.html[Guide to using proxies] for further details.

=== Maven HTTP headers

For adding custom headers to outgoing HTTP requests, existing Maven configuration in `~/.m2/settings.xml` is used.

[source,xml]
----
<settings>
  ...
  <servers>
    <server>
      <id>my-token-repo</id>
      <configuration>
        <httpHeaders>
          <property>
            <name>Private-Token</name>
            <value>abc123</value>
          </property>
        </httpHeaders>
      </configuration>
    </server>
    ...
  </servers>
  ...
</settings>
----

The server id in `settings.xml` must match the repository name in `deps.edn`:

[source,clojure]
----
{:mvn/repos
 {"my-token-repo" {:url "https://my.auth.com/repo"}}}
----

This mechanism is used by repositories that authenticate using a token, rather than by username and password.

== Git

The supported git url protocols are https and ssh. https repos will be accessed anonymously and require no additional authentication information. This approach is recommended for public repos.

ssh repos may be either public or private. Access to a git repo via ssh requires an ssh keypair. The private key of this keypair may or may not have a passphrase. ssh authentication works by connecting to the local ssh agent (ssh-agent on *nix or Pageant via PuTTY on Windows).
The ssh-agent must have a registered identity for the key being used to access the Git repository.
To check whether you have registered identities, use:

[source,shell]
----
$ ssh-add -l
2048 SHA256:S2SMY1YRTRFg3sqsMy1eTve4ag78XEzhbzzdVxZroDk /Users/me/.ssh/id_rsa (RSA)
----

which should return one or more registered identities, typically the one at `~/.ssh/id_rsa`.

For more information on creating keys and using the ssh-agent to manage your ssh identities, GitHub provides excellent info:

* https://help.github.com/articles/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent/
* https://help.github.com/articles/working-with-ssh-key-passphrases/

_Note: user/password authentication is not supported for any protocol._

== Installers

For tools installation, see the instructions in the <<xref/../../guides/getting_started#,Getting Started>> guide.

== Command line reference

=== Quoting keys and values

Key/value pairs are read as edn strings. In general, it is always safe to surround the edn value with single quotes `'data'` which will be read as edn data. In some cases (particularly numbers and keywords), you can omit the single quotes as bash does not have any conflicting interpretation. Examples by data type:

* Numbers - `123`, `12.4`
* Booleans - `true`, `false`
* Nil - `nil`
* Symbols - `name`, `foo/bar`
* Strings - `'"hi there"'` - note use of both single AND double quotes - single are for the shell, double make it an edn string
* Keywords - `:id`, `:company/name`
* Vectors - `[1,2]`, `'[1 2 3]'`
* Maps - `'{:a 1, :b 2}'`
* Sets - `'#{:a :b}'`
* Lists - `'(1 2 3)'`

== Glossary

**Library**

An independently-developed chunk of code residing in a directory hierarchy under a root.  We will narrow to those libraries that can be globally named, e.g. `my.namespace/my-lib`.

**Artifact**

A snapshot of a library, captured at a point in time, possibly subjected to some build process, labeled with a version, containing some manifest documenting its dependencies, and packaged in e.g. a jar.

**Coordinate**

A particular version of a library chosen for use, with information sufficient to obtain and use the library.

**Dependency**

An expression, at the project/library level, that the declaring library needs the declared library in order to provide some of its functions. Must at least specify library name, might also specify version and other attrs. Actual (functional) dependencies are more fine-grained. 

Dependency types:

* maven artifacts
* unversioned libraries - a file location identifying a jar or directory root
* git coordinates

**Classpath (and roots/paths)**

An ordered list of local 'places' (filesystem directories and/or jars) that will form root paths for searches of requires/imports at runtime, supplied as an argument to Java which controls the semantics. We discourage order-dependence in the classpath, which implies something is duplicated (and thus likely broken).

**Expansion**

Given a set of root dependencies, a full walk of the transitive dependencies.

**Resolution**

Given a collection of root dependencies and additional modifications, creates a fully-expanded dependency tree, then produces a mapping from each library mentioned to a single version to be used that would satisfy all dependents, as well as the local path. We will also include those dependents for each entry. Conflicts arise only if libraries depend on different major versions of a library.

**Classpath creation**

Creates a classpath from a resolved lib-map and optional extra local lib paths. Current plan for lib-map does not provide for control over resulting order.

**Version**

A human numbering system whose interpretation is determined by convention. Usually x.y.z. Must protect against 'semver' interpretation, which allows libraries to break users while keeping the name the same. Ascending by convention - higher numbers are 'later', vague compatibility with lower/earlier.

**Version difference**

This occurs when the dependency expansion contains the same library with more than one "version" specified but where there is a relative ordering (either by number or by SHA etc). Version differences can be resolved by choosing the "later" or "newest" version when that relationship can be established.

**Version conflict**

A version conflict occurs when the dependency expansion contains the same library with more than one "version" such that the best choice cannot be automatically chosen:

* semver version breakage (major version changed)
* github shas that do not contain any common root or ancestry (two shas on different branches or unrelated repos, for example)
* versions that cross different repos or repo types such that no relative relationship can be established

**Maven Repo**

A repository of library artifacts - e.g. Maven central or Clojars

**Requires and imports**

Mentions in source code of library (sub)components that must be in the classpath in order to succeed. namespace and package/class names are transformed into path components.

== Tools

See the project's wiki for a https://github.com/clojure/tools.deps.alpha/wiki/Tools[list of tools that use or work with tools.deps.alpha (or the clojure tools)] - tools for project creation, packaging, and much more.
